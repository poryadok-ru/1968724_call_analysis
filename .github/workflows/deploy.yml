name: Deploy CallQ to Production

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker image
        run: |
          docker build -t callq:latest .
      
      - name: Save Docker image
        run: |
          docker save callq:latest | gzip > callq.tar.gz
      
      - name: Create directory structure on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          script: |
            mkdir -p /opt/callq/callQ/{logs,prompts}
            chmod 755 /opt/callq/callQ
            chmod 755 /opt/callq/callQ/logs
            chmod 755 /opt/callq/callQ/prompts
      
      - name: Copy Docker image to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          source: "callq.tar.gz"
          target: "/opt/callq/callQ"
          strip_components: 0
      
      - name: Copy prompts to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          source: "prompts/*"
          target: "/opt/callq/callQ/prompts"
          strip_components: 0
      
      - name: Fix prompts directory structure
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          script: |
            cd /opt/callq/callQ
            # Исправляем структуру директорий, если промпты попали в prompts/prompts/
            if [ -d "prompts/prompts" ]; then
              mv prompts/prompts/* prompts/ 2>/dev/null || true
              rmdir prompts/prompts 2>/dev/null || true
              echo "Fixed prompts directory structure"
            fi
            # Проверяем наличие промптов
            ls -la prompts/*.txt || echo "Warning: No prompt files found"
      
      - name: Copy docker-compose files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          source: "docker-compose.department*.yml,Dockerfile,requirements.txt"
          target: "/opt/callq/callQ"
          strip_components: 0
      
      - name: Create .env files and deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          script: |
            cd /opt/callq/callQ
            
            # Функция для создания .env файла отдела
            create_env_file() {
              local env_file=$1
              local agent_group_name=$2
              local requirements_check_list=$3
              local requirements_prompt=$4
              local departament_id=$5
              local prompt_file=$6
              
              cat > "$env_file" << EOF
            LOGGING_NAME=${{ secrets.LOGGING_NAME }}
            LOGGING_LEVEL=${{ secrets.LOGGING_LEVEL }}
            LOGGING_DIR=${{ secrets.LOGGING_DIR }}
            LOGGING_ON_CONSOLE=${{ secrets.LOGGING_ON_CONSOLE }}
            LOGGING_ON_FILE=${{ secrets.LOGGING_ON_FILE }}
            LOGGING_ON_DT=${{ secrets.LOGGING_ON_DT }}
            LOGIN=${{ secrets.LOGIN }}
            PASSWORD=${{ secrets.PASSWORD }}
            AUTH_TYPE=${{ secrets.AUTH_TYPE }}
            AUTH_SYSTEM=${{ secrets.AUTH_SYSTEM }}
            AGENT_GROUP_NAME=${agent_group_name}
            REQUIREMENTS_SHEET_ID=${{ secrets.REQUIREMENTS_SHEET_ID }}
            REQUIREMENTS_SHEET_NAME_CHECK_LIST=${requirements_check_list}
            REQUIREMENTS_SHEET_NAME_PROMPT_FOR_AI=${requirements_prompt}
            TOKEN_LLM=${{ secrets.TOKEN_LLM }}
            MODEL=${{ secrets.MODEL }}
            DATA_BASE=${{ secrets.DATA_BASE }}
            DEPARTAMENT_ID=${departament_id}
            CHECK_DAY_AGO=${{ secrets.CHECK_DAY_AGO }}
            PROMPT_FILE=${prompt_file}
            EOF
            }
            
            # Создаем .env файлы для обоих отделов
            create_env_file .env.department1 \
              "${{ secrets.DEPT1_AGENT_GROUP_NAME }}" \
              "${{ secrets.DEPT1_REQUIREMENTS_SHEET_NAME_CHECK_LIST }}" \
              "${{ secrets.DEPT1_REQUIREMENTS_SHEET_NAME_PROMPT_FOR_AI }}" \
              "${{ secrets.DEPT1_DEPARTAMENT_ID }}" \
              "${{ secrets.DEPT1_PROMPT_FILE }}"
            
            create_env_file .env.department2 \
              "${{ secrets.DEPT2_AGENT_GROUP_NAME }}" \
              "${{ secrets.DEPT2_REQUIREMENTS_SHEET_NAME_CHECK_LIST }}" \
              "${{ secrets.DEPT2_REQUIREMENTS_SHEET_NAME_PROMPT_FOR_AI }}" \
              "${{ secrets.DEPT2_DEPARTAMENT_ID }}" \
              "${{ secrets.DEPT2_PROMPT_FILE }}"
            
            chmod 600 .env.department1 .env.department2
            
            # Загружаем Docker образ
            docker load < callq.tar.gz
            
            # Останавливаем старые контейнеры (если запущены)
            docker compose -f docker-compose.department1.yml down 2>/dev/null || true
            docker compose -f docker-compose.department2.yml down 2>/dev/null || true
            
            # Удаляем старые контейнеры
            docker rm callq-department1 callq-department2 2>/dev/null || true
            
            # Показываем информацию о собранном образе
            docker images callq:latest
            
            echo "Docker image loaded successfully!"
            echo "Containers will be started by cron jobs"
            
            # Очищаем старые образы (оставляем только последние 2)
            docker images callq --format "{{.ID}}" | tail -n +3 | xargs -r docker rmi 2>/dev/null || true
            
            echo "Deployment successful!"
      
      - name: Update cron jobs
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          script: |
            # Создаем временный crontab файл
            TMP_CRON=$(mktemp)
            
            # Сохраняем текущий crontab пользователя deploy (если есть)
            sudo -u deploy crontab -l > "$TMP_CRON" 2>/dev/null || touch "$TMP_CRON"
            
            # Удаляем старые задачи callq (если есть)
            sed -i '/callq/d' "$TMP_CRON"
            
            # Создаем файл с JSON ключом для использования в cron
            cat > /opt/callq/callQ/.google_json_key << 'JSONEOF'
            ${{ secrets.GOOGLE_JSON_KEY }}
            JSONEOF
            chmod 600 /opt/callq/callQ/.google_json_key
            
            # Добавляем новые задачи для обоих отделов
            cat >> "$TMP_CRON" << 'EOF'
            # CallQ - Отдел 1 (Торговые представители)
            0 3 * * * cd /opt/callq/callQ && export JSON_AUTH="$(cat .google_json_key)" && docker compose -f docker-compose.department1.yml up -d >> /opt/callq/callQ/logs/cron.log 2>&1
            
            # CallQ - Отдел 2 (Офис-менеджеры)
            10 3 * * * cd /opt/callq/callQ && export JSON_AUTH="$(cat .google_json_key)" && docker compose -f docker-compose.department2.yml up -d >> /opt/callq/callQ/logs/cron.log 2>&1
            EOF
            
            # Устанавливаем новый crontab для пользователя deploy
            sudo -u deploy crontab "$TMP_CRON"
            rm "$TMP_CRON"
            
            # Показываем текущий crontab
            echo "Current crontab:"
            sudo -u deploy crontab -l | grep callq || echo "No callq jobs found"
      
      - name: Cleanup
        if: always()
        run: |
          rm -f callq.tar.gz

